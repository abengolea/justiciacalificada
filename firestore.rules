/**
 * Core Philosophy: This ruleset establishes a security model for a lawyer-driven courthouse rating application.
 * It provides a mix of private user-owned data, publicly readable content, and admin-managed entities.
 * The primary goals are to ensure lawyers can only manage their own profiles and ratings, protect the integrity
 * of courthouse data, and restrict sensitive operations to administrators.
 *
 * Data Structure:
 * - /lawyers/{uid}: Private user profiles, where the document ID matches the user's Auth UID. Admins have a 'role: "admin"' field here.
 * - /juzgados/{juzgadoId}: Publicly available information about courthouses.
 * - /juzgados/{juzgadoId}/ratings/{ratingId}: User-submitted ratings, which are publicly readable.
 * - /juzgados/{juzgadoId}/statistics/{statisticId}: Publicly readable, aggregated statistics, not writable by clients.
 *
 * Key Security Decisions:
 * - Strict Ownership: A lawyer's profile in `/lawyers` is strictly private and can only be accessed or modified by the owner, unless the user is an admin.
 * - Public Read, Admin Write: Core data like `/juzgados` is readable by anyone but can only be modified by users designated as admins.
 * - Denormalized Ownership for Subcollections: Each `rating` document contains a `lawyerId` field. This denormalization is critical for security, allowing write-access checks directly on the document.
 * - Read-Only Data: Aggregated data like `/statistics` is completely locked down from client writes to ensure data integrity.
 *
 * Denormalization for Authorization:
 * To create simpler, more performant rules, we denormalize the `lawyerId` onto each `rating` document. This allows a fast, simple rule like `isOwner(resource.data.lawyerId)` without any extra `get()` calls to check who created the rating.
 *
 * Structural Segregation:
 * The data is naturally segregated into top-level collections based on access patterns (e.g., private `lawyers` vs. public `juzgados`), which is a secure and performant design.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingDoc() {
      return resource != null;
    }

    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/lawyers/$(request.auth.uid)).data.role == 'admin';
    }

    function isApprovedLawyer() {
      return isSignedIn() && get(/databases/$(database)/documents/lawyers/$(request.auth.uid)).data.status == 'approved';
    }

    function isValidNewLawyer(uid) {
      let data = request.resource.data;
      
      // A regular lawyer registration
      let isNormalRegistration = (
        data.status == 'pending' &&
        data.role == 'user' &&
        data.registrationDate == request.time
      );

      // The special one-time admin bootstrap for the login flow
      let isAdminBootstrap = (
        data.status == 'approved' &&
        data.role == 'admin' &&
        data.email == 'abengolea1@gmail.com'
      );

      return data.uid == uid &&
             data.nombre is string && data.nombre.size() > 0 &&
             data.apellido is string && data.apellido.size() > 0 &&
             data.email is string && data.email.matches('.+@.+\\..+') &&
             data.matricula is string &&
             data.fechaMatriculacion is string &&
             data.credencialUrl is string &&
             (isNormalRegistration || isAdminBootstrap);
    }

    function isValidLawyerUpdate(uid) {
        let data = request.resource.data;
        let existingData = resource.data;
        
        let coreFieldsUnchanged = data.uid == existingData.uid &&
                                  data.email == existingData.email &&
                                  data.registrationDate == existingData.registrationDate;

        // A regular user can update their own profile, but cannot change their role or status.
        let ownerCanUpdate = isOwner(uid) &&
                             !isAdmin() && // An admin updating their own profile falls under adminCanUpdate
                             coreFieldsUnchanged &&
                             data.role == existingData.role &&
                             data.status == existingData.status;

        // An admin can update any user's profile, except for the core immutable fields.
        let adminCanUpdate = isAdmin() && coreFieldsUnchanged;

        return ownerCanUpdate || adminCanUpdate;
    }


    function isValidNewRating(juzgadoId) {
      let data = request.resource.data;
       let hasValidPuntuaciones = data.puntuaciones.calidadResoluciones >= 0 && data.puntuaciones.calidadResoluciones <= 10 &&
                             data.puntuaciones.rapidezResoluciones >= 0 && data.puntuaciones.rapidezResoluciones <= 10 &&
                             data.puntuaciones.rapidezDespacho >= 0 && data.puntuaciones.rapidezDespacho <= 10 &&
                             data.puntuaciones.atencionMesaEntradas >= 0 && data.puntuaciones.atencionMesaEntradas <= 10 &&
                             data.puntuaciones.tratoProfesional >= 0 && data.puntuaciones.tratoProfesional <= 10 &&
                             data.puntuaciones.puntualidadAudiencias >= 0 && data.puntuaciones.puntualidadAudiencias <= 10 &&
                             data.puntuaciones.ordenGeneral >= 0 && data.puntuaciones.ordenGeneral <= 10 &&
                             data.puntuaciones.tecnologia >= 0 && data.puntuaciones.tecnologia <= 10 &&
                             data.puntuaciones.practicidad >= 0 && data.puntuaciones.practicidad <= 10 &&
                             data.puntuaciones.capacitacionPersonal >= 0 && data.puntuaciones.capacitacionPersonal <= 10;
      
      return isOwner(data.lawyerId) &&
             data.courthouseId == juzgadoId &&
             data.status == 'pending' &&
             data.fechaCalificacion == request.time &&
             data.comentario is string && data.comentario.size() >= 10 && data.comentario.size() <= 500 &&
             data.fechaExperiencia is string &&
             hasValidPuntuaciones;
    }

    function areRatingFieldsImmutable() {
      return request.resource.data.lawyerId == resource.data.lawyerId &&
             request.resource.data.courthouseId == resource.data.courthouseId;
    }


    // ----------------------------------------------------------------
    // Rules
    // ----------------------------------------------------------------

    match /lawyers/{uid} {
      allow get: if isOwner(uid) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(uid) && isValidNewLawyer(uid);
      allow update: if isExistingDoc() && isValidLawyerUpdate(uid);
      allow delete: if isAdmin() && isExistingDoc();
    }
    
    // --- Rules for bulk data import by admin ---
    
    // Public data collections that are only writable by admins.
    match /provincias/{docId}         { allow read: if true; allow write: if isAdmin(); }
    match /departamentos/{docId}      { allow read: if true; allow write: if isAdmin(); }
    match /ciudades/{docId}           { allow read: if true; allow write: if isAdmin(); }
    match /categorias/{docId}         { allow read: if true; allow write: if isAdmin(); }
    match /fueros/{docId}             { allow read: if true; allow write: if isAdmin(); }
    match /dependencias/{docId}       { allow read: if true; allow write: if isAdmin(); }
    match /ranking_general/{docId}    { allow read: if true; allow write: if isAdmin(); }
    match /historico/{docId}          { allow read: if true; allow write: if isAdmin(); }

    match /juzgados/{juzgadoId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();

      match /ratings/{ratingId} {
        allow get, list: if true;
        allow create: if isApprovedLawyer() && isValidNewRating(juzgadoId);
        allow update: if (isOwner(resource.data.lawyerId) || isAdmin()) && isExistingDoc() && areRatingFieldsImmutable();
        allow delete: if (isOwner(resource.data.lawyerId) || isAdmin()) && isExistingDoc();
      }

      match /statistics/{statisticId} {
        allow get, list: if true;
        allow create, update, delete: if false;
      }
    }
    
    // Join table for fueros and juzgados
    match /fueros_x_juzgados/{docId}  { allow read: if true; allow write: if isAdmin(); }

    // Collections that only admins should be able to write to during import.
    // Read access is also limited to admins for these potentially sensitive/legacy tables.
    match /usuarios/{docId}           { allow read, write: if isAdmin(); }
    match /administradores/{docId}    { allow read, write: if isAdmin(); }
    match /comentarios/{docId}        { allow read, write: if isAdmin(); }
    match /matriculas/{docId}         { allow read, write: if isAdmin(); }
    match /permisos/{docId}           { allow read, write: if isAdmin(); }
    match /votantes/{docId}           { allow read, write: if isAdmin(); }
    match /votantes_temp/{docId}      { allow read, write: if isAdmin(); }
    match /votos/{docId}              { allow read, write: if isAdmin(); }
    match /votos_comentarios/{docId}  { allow read, write: if isAdmin(); }

    // Collection for logging import errors
    match /import_errors/{docId}      { allow read, write: if isAdmin(); }


    // This rule allows the collection group query for 'ratings' to work.
    // It's needed for the main courthouse list page to calculate average ratings.
    match /{path=**}/ratings/{ratingId} {
      allow get, list: if true;
    }

    match /mail/{mailId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }
  }
}
